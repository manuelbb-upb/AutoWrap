# AutoWrap.jl
## Automatic Specialization of Functions 

A result from musings concerning https://github.com/JuliaSymbolics/Symbolics.jl/pull/813.

## Questions

Testing is needed! Does this solve pre-compilation issues?

## Examples

Explicit `AutoWrapContext`:
```julia
using AutoWrap

specialize_reals(x) = x
specialize_reals(T::Type{<:Real}) = [T, Int, Float16, BigFloat]

ctx = AutoWrapContext(;
    arg_type_mapping = specialize_reals
)

@wrapping ctx # defines @ctx_wrap

@ctx_wrap function my_sum(a::Real, b::Number)
    return a + b
end
```

Now there is `my_sum(a::Real, b::Number)` but also methods for `(a::Int64, b::Number)`, 
`(a::Float16, b::Number)` and `(a::BigFloat, b::Number)`.

Same result:
```julia
using AutoWrap

specialize_reals(x) = x
specialize_reals(T::Type{<:Real}) = [T, Int, Float16, BigFloat]

@wrapping ctx = AutoWrapContext(;
    arg_type_mapping = specialize_reals
)

@ctx_wrap function my_sum(a::Real, b::Number)
    return a + b
end
```
or
```julia
using AutoWrap

specialize_reals(x) = x
specialize_reals(T::Type{<:Real}) = [T, Int, Float16, BigFloat]

ctx = AutoWrapContext(;
    arg_type_mapping = specialize_reals
)

AW.@wrap ctx function my_sum(a::Real, b::Number)
    return a + b
end
```

The macros call `eval` in their expansion context (`__module__`).
The expression is actually generated by `AW.superwrapper(__module__, ctx_ex, func_ex)`.


